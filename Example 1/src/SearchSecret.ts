/*Example 1*/

const PATH_RDF_lib = '../URDNA2015lib';
const URDNAalg = require(PATH_RDF_lib+'/URDNA2015');
const NQuads = require(PATH_RDF_lib+'/NQuads');
var fs = require('fs');
const jsonld = require('jsonld');
const crypto = require('crypto');

import Credential from "./data/DerivedCredential.json";

const hashAlgorithm = 'sha256';

// Load the names to check
const NamesFile = fs.readFileSync('./src/data//names.txt', 'utf8', function(err: any, data: any) {
  if (err) throw err;
  console.log('OK');
});

const names: string[] = NamesFile.split('\n');
console.log("Loaded "+names.length + " names...");



// Canonize a VC using URDNA2015 to get the quads used by that algorithm,
// which will become the reference set of each blank node later
// (using a slitely reformed version of URDNA2015 to return those quads)
async function doCanonize(VC: any) {

	const VCtoRDF = await jsonld.toRDF(VC, { produceGeneralizedRdf: false });
	console.log("Done Converting to RDF...");

	const canonize = new URDNAalg();

	const CanonizedResults = await canonize.main(VCtoRDF); // canonize with URDNA2015 

	const RefernceSets = CanonizedResults[1];

	console.log("Done Canonization...");
	console.log("Reference Sets: ");
	console.log(RefernceSets);
	return RefernceSets
};



// Return the hash of a reference set (h(Qn)) of a blank node, after
// replaising all the empty ("_") values with hypothesized ones 
// (e.g. after hypothizing that the Holders name is "Jane", replace
// "_" with "Jane").
function getReferenceSetHash(VARIABLE: any, BlankNode_Quads: any) {
	const md = crypto.createHash(hashAlgorithm);
	var quads: any[] = []
	for (const quad of BlankNode_Quads) {
		const indx = quad.search('\"_\"')
		if (indx != -1) {
			var new_quad = quad.split('\"_\"');
			quads.push(new_quad[0] + '\"' + `${VARIABLE}` + '\"' + new_quad[1]);
		} else { quads.push(quad) };
	}

	quads.sort();

	for (const quad of quads) {
		md.update(quad);
	};

	return md.digest('hex')
};


const search = async (DisclosedVCdata: any): Promise<void> => {	
	// Load the hypothized core of the VC
	const HypothesizeddVCfile = fs.readFileSync("./src/data/HypothesizedCredential.json");
	const HypothesizedVCdata = JSON.parse(HypothesizeddVCfile);


	// ---> Replase the disclosed values in the hypothesized VC
	const keys = Object.keys(DisclosedVCdata);
	if (keys.includes("address")) {
		HypothesizedVCdata["address"]["postalAddress"] = DisclosedVCdata["address"]["postalAddress"];
	}
	else if (keys.includes("firstName")) {
		HypothesizedVCdata["firstName"] = DisclosedVCdata["firstName"];
	}
	else {
		console.log("No values have been disclosed");
	};


	// ---> Search every name
	const results: any[] = [];
	const ReferenceSets = await doCanonize(HypothesizedVCdata);  // reference sets Qi

	// The id derived from the second blank node canonical label
	const BlankNode_ID = DisclosedVCdata["address"]["id"];

	// Depending on the id fields search for a name for which
	// h(Q1) > h(Q2) or h(Q1) < h(Q2).
	console.log("------------------------------------------------------------------------");
	console.time("Search Time"); // Timing the search
	if (BlankNode_ID == "urn:bnid:_:c14n1") {
		console.log("Searching for h(Q1) < h(Q2)...");
		for (const name of names) {
			const FirstBlankNode_Quads = ReferenceSets[0];  // First reference set Q1
			const SecondBlankNode_Quads = ReferenceSets[1]; // Second reference set Q2

			// Hash of the reference sets elements
			const FirstBlankNode_hash = getReferenceSetHash(name, FirstBlankNode_Quads);
			const SecondBlankNode_hash = getReferenceSetHash("", SecondBlankNode_Quads);

			// chsck if the inequality h(Q1) < h(Q2) holds, which results
			// in the id "urn:bnid:_:c14n1"
			if (FirstBlankNode_hash < SecondBlankNode_hash) {
				//console.log(name);
				results.push(name);
			}
		}
	}
	else if (BlankNode_ID == "urn:bnid:_:c14n0") {
		console.log("Searching for h(Q1) > h(Q2)...")
		for (const name of names) {
			const FirstBlankNode_Quads = ReferenceSets[0]; // First reference set Q1
			const SecondBlankNode_Quads = ReferenceSets[1]; // Second reference set Q2

			// Hash of the reference sets elements
			const FirstBlankNode_hash = getReferenceSetHash(name, FirstBlankNode_Quads);
			const SecondBlankNode_hash = getReferenceSetHash("", SecondBlankNode_Quads);

			// chsck if the inequality h(Q1) > h(Q2) holds, which results
			// in the id "urn:bnid:_:c14n0"
			if (FirstBlankNode_hash > SecondBlankNode_hash) {
				//console.log(name);
				results.push(name);
			}
		}
	}
	else { throw "ERR: Unrecognized ID field" };

	console.log("Search Done. \nNames Found: " + results.length);
	console.timeEnd("Search Time");
	console.log("============================== Results =================================");
	console.log("Possible Names: ");
	console.log(results);

}



// Load and parse the Derived Crendential file. If the file is not empty and is
// parsed correctly, search for the secret claim of the holder.
function readJSONandSearch(path, search_callback) {
	const JSONfile = fs.readFileSync(path);
	if (Object.keys(JSONfile).length == 0) {
		// The DerivedCredential.json is empty.
		search_callback(Error("Derived Credential File: DerivedCredential.json is empty. Possibly you must run 'yarn generate' first."));
	}
	else {
		// The DerivedCredential.json is not empty. Run the search function
		search_callback(null, JSONfile);
	};
};

// use the readJSONandSearch with the coresponding callback
readJSONandSearch("./src/data/DerivedCredential.json", function (err, json_file) {
	if (err) {
		console.log("ERROR: ", err.message);
	}
	else {
		try {
			var parsed_JSON = JSON.parse(json_file);
		} catch (SyntaxError) {
			console.log("Error: DerivedCredential.json file has incorrect format. Try runing 'yarn generate' again.");
		};

		if (parsed_JSON) {
			search(parsed_JSON);
		};
	}
});