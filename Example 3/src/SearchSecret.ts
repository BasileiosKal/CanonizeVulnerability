/*Example 3*/

const PATH_RDF_lib = '../URDNA2015lib';
const URDNAalg = require(PATH_RDF_lib+'/URDNA2015');
const NQuads = require(PATH_RDF_lib+'/NQuads');
var fs = require('fs');
const jsonld = require('jsonld');
const crypto = require('crypto');

import Credential from "./data/DerivedCredential.json";

const hashAlgorithm = 'sha256';
const PO_NUMBER = 100000; // 5-digit PO numbers at most


// Load and parse Crendential file
const VCfile = fs.readFileSync("./src/data/DerivedCredential.json");
const VCdata = JSON.parse(VCfile);

console.log("Done Loading Derived Credential...")
// console.log("------------------------------------------------------------------------");
// console.log(">>> Credential Received by the Verifier: ")
// console.log(JSON.stringify(VCdata, null, 2));
// console.log("------------------------------------------------------------------------");


// Load the hypothized core of the VC
const HypothesizeddVCfile = fs.readFileSync("./src/data/HypothesizedCredential.json");
const HypothesizedVCdata = JSON.parse(HypothesizeddVCfile);


// Replase the disclosed values in the hypothesized VC
const keys = Object.keys(VCdata);
if(keys.includes("address")){
	HypothesizedVCdata["address"]["postalAddress"] = VCdata["address"]["postalAddress"];
}
else if(keys.includes("firstName")){
	HypothesizedVCdata["firstName"] = VCdata["firstName"];
}
else{
	console.log("No values have been disclosed");
};


// Canonize a VC using URDNA2015 to get the quads used by that algorithm,
// which will become the reference set of each blank node later
// (using a slitely reformed version of URDNA2015 to return those quads)
async function doCanonize(VC: any){

  const VCtoRDF = await jsonld.toRDF(VC, {produceGeneralizedRdf: false});
  console.log("Done Converting to RDF...");

  const canonize = new URDNAalg();

  const CanonizedResults = await canonize.main(VCtoRDF); // canonize with URDNA2015 
  const RefernceSets = CanonizedResults[1]

  console.log("Done Canonization...");
  console.log("Reference Sets: ");
  console.log(RefernceSets);
  return RefernceSets
};


// Return the hash of a reference set (h(Qn)) of a blank node, after
// replaising all the empty ("_") values with hypothesized ones 
// (e.g. after hypothizing that the Holders name is "Jane", replace
// "_" with "Jane").
function getReferenceSetHash(VARIABLE: any, BlankNode_Quads: any){
	const md = crypto.createHash(hashAlgorithm);
	var quads: any[] = []
	for(const quad of BlankNode_Quads){
		const indx = quad.search('\"_\"')
		if(indx != -1){
			var new_quad = quad.split('\"_\"');
			quads.push(new_quad[0]+'\"' + `${VARIABLE}` + '\"'+ new_quad[1]);
		} else{quads.push(quad)};
	}

	quads.sort();

	for(const quad of quads){
		md.update(quad);
	};

	return  md.digest('hex')
};


// Search every PO number
async function searchPostalAddress(VCdata: any, HypothesizedVCdata: any, PostalAdd: any){
	const results:any[] = [];

	const ReferenceSets = await doCanonize(HypothesizedVCdata);  // reference sets Qi
	
	// The id derived from the first blank node canonical label
	const BlankNode_ID = VCdata["id"];

	// Depending on the id fields search for a POnumber for which
	// h(Q1) > h(Q2) or h(Q1) < h(Q2).
	console.log("------------------------------------------------------------------------");
	console.time("Search Time"); // Timing the search
	if(BlankNode_ID == "urn:bnid:_:c14n0"){ 
		console.log("Searching for h(Q1) < h(Q2)...");
		for(const POnumber of PostalAdd){
			const FirstBlankNode_Quads = ReferenceSets[0];  // First reference set Q1
			const SecondBlankNode_Quads = ReferenceSets[1]; // Second reference set Q2

			// Hash of the reference sets elements
			const FirstBlankNode_hash = getReferenceSetHash("", FirstBlankNode_Quads);
			const SecondBlankNode_hash = getReferenceSetHash(POnumber, SecondBlankNode_Quads);
      
      // chsck if the inequality h(Q1) < h(Q2) holds, which results
      // in the id "urn:bnid:_:c14n0"
			if(FirstBlankNode_hash<SecondBlankNode_hash){
				results.push(POnumber);
			}
		}
	}
	else if(BlankNode_ID == "urn:bnid:_:c14n1"){
		console.log("Searching for h(Q1) > h(Q2)...")
		for(const POnumber of PostalAdd){
			const FirstBlankNode_Quads = ReferenceSets[0]; // First reference set Q1
			const SecondBlankNode_Quads = ReferenceSets[1]; // Second reference set Q2

			// Hash of the reference sets elements
			const FirstBlankNode_hash = getReferenceSetHash("", FirstBlankNode_Quads);
			const SecondBlankNode_hash = getReferenceSetHash(POnumber, SecondBlankNode_Quads);

			// chsck if the inequality h(Q1) > h(Q2) holds, which results
      // in the id "urn:bnid:_:c14n1"
			if(FirstBlankNode_hash>SecondBlankNode_hash){
				results.push(POnumber);
			}
		}
	}
	else{throw "ERR: Unrecognized ID field"};

	console.log("Search Done. \nPostal Addresses Found: " + results.length);
	console.timeEnd("Search Time");
	console.log("============================== Results =================================");
	console.log("Possible Postal Addresses (PO numbers): ")
	console.log(results)
};

searchPostalAddress(VCdata, HypothesizedVCdata, [...Array(PO_NUMBER).keys()])


