/*Example 2*/

const PATH_RDF_lib = '../URDNA2015lib';
const URDNAalg = require(PATH_RDF_lib+'/URDNA2015');
const NQuads = require(PATH_RDF_lib+'/NQuads');
var fs = require('fs');
const jsonld = require('jsonld');
const crypto = require('crypto');

import Credential from "./data/DerivedCredential.json";

const hashAlgorithm = 'sha256';
const ITEM_IDs_NUMBER = 10000; // 4-digit item IDs

// Load and parse Crendential file
const VCfile = fs.readFileSync("./src/data/DerivedCredential.json");
const VCdata = JSON.parse(VCfile);

console.log("Done Loading Derived Credential...");

// Load the hypothized core of the VC
const HypothesizeddVCfile = fs.readFileSync("./src/data/HypothesizedCredential.json");
const HypothesizedVCdata = JSON.parse(HypothesizeddVCfile);


// Replace the disclosed values in the hypothesized VC
// Note: Here i choose the second item of the "item" list to put the
// 		   known item_ID value. However, that choice doesn't really matter, since 
//       the keys of the credential and hence, also the reference sets, are identical
//       (except of the item_ID value). To simplify the code i hardcode it it here. If
//       the first element of the "item" list was chosen instead, only the inequalities in
//       the search_ItemIDs function must be changed, since the only difference is 
//       that we are looking for the secret value effecting the second blank node and not
//       the first.
// TO_DO: fix that.
HypothesizedVCdata["item"][1]["item_ID"] = VCdata["item"]["item_ID"];


// Canonize a VC using URDNA2015 to get the quads used by that algorithm,
// which will become the reference set of each blank node later
// (using a slitely reformed version of URDNA2015 to return those quads)
async function doCanonize(VC: any){

  const VCtoRDF = await jsonld.toRDF(VC, {produceGeneralizedRdf: false});
  console.log("Done Converting to RDF...");

  const canonize = new URDNAalg();

  const CanonizedResults = await canonize.main(VCtoRDF); // canonize with URDNA2015
  const RefernceSets = CanonizedResults[1]

  console.log("Done Canonization...");
  console.log("Reference Sets: ");
  console.log(RefernceSets);
  return RefernceSets
};


// Return the hash of a reference set (h(Qn)) of a blank node, after
// replaising all the empty ("_") values with hypothesized ones 
// (e.g. after hypothizing that the Holders name is "Jane", replace
// "_" with "Jane").
function getReferenceSetHash(VARIABLE: any, BlankNode_Quads: any){
	const md = crypto.createHash(hashAlgorithm);
	var quads: any[] = []
	for(const quad of BlankNode_Quads){
		const indx = quad.search('\"_\"')
		if(indx != -1){
			var new_quad = quad.split('\"_\"');
			quads.push(new_quad[0]+'\"' + `${VARIABLE}` + '\"'+ new_quad[1]);
		} else{quads.push(quad)};
	}

	quads.sort();

	for(const quad of quads){
		md.update(quad);
	};

	return  md.digest('hex')
};


// Search every possible item_ID
async function search_ItemIDs(VCdata: any, HypothesizedVCdata: any, item_IDs: any){
	const results:any[] = [];

	const ReferenceSets = await doCanonize(HypothesizedVCdata);  // reference sets Qi
	
	// The id derived from the second blank node canonical label
	const BlankNode_ID = VCdata["item"]["id"];

	// Depending on the id fields search for a item_ID for which
	// h(Q1) > h(Q2) or h(Q1) < h(Q2).
	console.log("------------------------------------------------------------------------");
	console.time("Search Time"); // Timing the search
	if(BlankNode_ID == "urn:bnid:_:c14n1"){ 
		console.log("Searching for h(Q1) < h(Q2)...");
		for(const item_id of item_IDs){
			const FirstBlankNode_Quads = ReferenceSets[0];  // First reference set Q1
			const SecondBlankNode_Quads = ReferenceSets[1]; // Second reference set Q2

			// Hash of the reference sets elements
			const FirstBlankNode_hash = getReferenceSetHash(item_id, FirstBlankNode_Quads);
			const SecondBlankNode_hash = getReferenceSetHash("", SecondBlankNode_Quads);
      
			// chsck if the inequality h(Q1) < h(Q2) holds, which results
			// in the id "urn:bnid:_:c14n1"
			if(FirstBlankNode_hash<SecondBlankNode_hash){
				results.push(item_id);
			}
		}
	}
	else if(BlankNode_ID == "urn:bnid:_:c14n0"){
		console.log("Searching for h(Q1) > h(Q2)...")
		for(const item_id of item_IDs){
			const FirstBlankNode_Quads = ReferenceSets[0]; // First reference set Q1
			const SecondBlankNode_Quads = ReferenceSets[1]; // Second reference set Q2

			// Hash of the reference sets elements
			const FirstBlankNode_hash = getReferenceSetHash(item_id, FirstBlankNode_Quads);
			const SecondBlankNode_hash = getReferenceSetHash("", SecondBlankNode_Quads);

			// chsck if the inequality h(Q1) > h(Q2) holds, which results
			// in the id "urn:bnid:_:c14n0"
			if(FirstBlankNode_hash>SecondBlankNode_hash){
				results.push(item_id);
			}
		}
	}
	else{throw "ERR: Unrecognized ID field"};

	console.log("Search Done. \nItem IDs Found: " + results.length);
	console.timeEnd("Search Time");
	console.log("============================== Results =================================");
	console.log("Possible Item IDs: ")
	console.log(results)
};


search_ItemIDs(VCdata, HypothesizedVCdata, [...Array(ITEM_IDs_NUMBER).keys()]);

